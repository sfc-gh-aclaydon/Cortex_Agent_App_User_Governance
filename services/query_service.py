import requests
import json
import os
import uuid
from dotenv import load_dotenv
from typing import Dict, Any, List
from models.database import SnowflakeConnection
from services.sql_masker import SQLMasker

class QueryService:
    def __init__(self):
        # Ensure environment variables are loaded
        load_dotenv()
        self.db = SnowflakeConnection()
        self.sql_masker = SQLMasker()
        self.semantic_view_name = "MAPS_SEARCH_ANALYTICS.APPLICATION.sales_analytics_semantic_view"
    
    def process_question(self, question: str, user_context: Dict[str, Any]) -> Dict[str, Any]:
        """Process natural language question through Cortex Analyst and execute SQL"""
        try:
            # Set session context in Snowflake
            self._set_session_context(user_context)
            
            # Call Cortex Analyst
            analyst_response = self._call_cortex_analyst(question)
            
            # Process response, execute SQL, and return results with data
            processed_response = self._process_analyst_response(analyst_response, user_context)
            
            return processed_response
            
        except Exception as e:
            raise Exception(f"Query processing failed: {str(e)}")
    
    def _set_session_context(self, user_context: Dict[str, Any]) -> None:
        """Set session variables for Row Access Policy"""
        try:
            with self.db.get_connection() as conn:
                cursor = conn.cursor()
                
                # Set session variables for RAP
                cursor.execute(f"""
                    SET current_user_id = {user_context['current_user_id']}
                """)
                
                cursor.execute(f"""
                    SET is_admin = {user_context['is_admin']}
                """)
                
                # Set accessible regions as JSON array
                regions_json = json.dumps([r['region_id'] for r in user_context['accessible_regions']])
                cursor.execute(f"""
                    SET accessible_regions = '{regions_json}'
                """)
                
        except Exception as e:
            raise Exception(f"Failed to set session context: {str(e)}")
    
    def _call_cortex_analyst(self, question: str) -> Dict[str, Any]:
        """Call Snowflake Cortex Analyst REST API"""
        try:
            with self.db.get_connection() as conn:
                # Get the REST authentication token from the connection
                token = conn.rest.token
                
                # Construct the account URL from connection parameters  
                account_identifier = self.db.connection_params['account']
                host_url = f"https://{account_identifier}.snowflakecomputing.com"
                
                # Construct request body according to Cortex Analyst REST API docs
                request_body = {
                    "messages": [
                        {
                            "role": "user", 
                            "content": [
                                {
                                    "type": "text",
                                    "text": question
                                }
                            ]
                        }
                    ],
                    "semantic_view": self.semantic_view_name
                }
                
                # Set required headers according to documentation
                headers = {
                    "Authorization": f'Snowflake Token="{token}"',
                    "Content-Type": "application/json"
                }
                
                # Make the API call to the Cortex Analyst endpoint
                response = requests.post(
                    url=f"{host_url}/api/v2/cortex/analyst/message",
                    json=request_body,
                    headers=headers
                )
                
                # Get request ID from response headers
                request_id = response.headers.get("X-Snowflake-Request-Id")
                
                # Check for API errors
                if response.status_code >= 400:
                    raise Exception(f"Cortex Analyst API error (status {response.status_code}): {response.text}")
                
                # Parse the JSON response and add request ID
                result = response.json()
                result['request_id'] = request_id
                
                return result
                
        except Exception as e:
            raise Exception(f"Cortex Analyst API call failed: {str(e)}")
    
    def _execute_sql_query(self, sql_statement: str, user_context: Dict[str, Any]) -> Dict[str, Any]:
        """Execute the SQL query generated by Cortex Analyst and return results"""
        try:
            with self.db.get_connection() as conn:
                cursor = conn.cursor()
                
                # Set session context for Row Access Policies before executing query
                cursor.execute(f"SET current_user_id = {user_context['current_user_id']}")
                cursor.execute(f"SET is_admin = {user_context['is_admin']}")
                
                # Set accessible regions as JSON array
                regions_json = json.dumps([r['region_id'] for r in user_context['accessible_regions']])
                cursor.execute(f"SET accessible_regions = '{regions_json}'")
                
                # Execute the SQL query
                cursor.execute(sql_statement)
                
                # Fetch column names
                columns = [desc[0] for desc in cursor.description] if cursor.description else []
                
                # Fetch all results
                rows = cursor.fetchall()
                
                # Convert to list of dictionaries for easy JSON serialization
                results = []
                for row in rows:
                    row_dict = {}
                    for i, value in enumerate(row):
                        # Handle different data types for JSON serialization
                        if hasattr(value, 'isoformat'):  # datetime objects
                            row_dict[columns[i]] = value.isoformat()
                        elif isinstance(value, (int, float, str, bool)) or value is None:
                            row_dict[columns[i]] = value
                        else:
                            row_dict[columns[i]] = str(value)
                    results.append(row_dict)
                
                return {
                    'success': True,
                    'columns': columns,
                    'data': results,
                    'row_count': len(results)
                }
                
        except Exception as e:
            return {
                'success': False,
                'error': f"SQL execution failed: {str(e)}",
                'columns': [],
                'data': [],
                'row_count': 0
            }

    def _process_analyst_response(self, analyst_response: Dict[str, Any], user_context: Dict[str, Any]) -> Dict[str, Any]:
        """Process Cortex Analyst response, execute SQL, and return results with data"""
        try:
            message = analyst_response.get('message', {})
            content = message.get('content', [])
            
            processed_content = []
            sql_statement = None
            sql_results = None
            
            for item in content:
                if item.get('type') == 'text':
                    processed_content.append({
                        'type': 'text',
                        'content': item.get('text', '')
                    })
                elif item.get('type') == 'sql':
                    sql_statement = item.get('statement', '')
                    
                    # Execute the SQL query to get actual results
                    sql_results = self._execute_sql_query(sql_statement, user_context)
                    
                    # Mask the SQL to remove security predicates for display
                    masked_sql = self.sql_masker.mask_security_predicates(sql_statement)
                    
                    # Add SQL content with results
                    processed_content.append({
                        'type': 'sql',
                        'content': masked_sql,
                        'confidence': item.get('confidence', {}),
                        'results': sql_results
                    })
                elif item.get('type') == 'suggestions':
                    processed_content.append({
                        'type': 'suggestions',
                        'content': item.get('suggestions', [])
                    })
            
            # If we have SQL results, also add a summary
            if sql_results and sql_results.get('success'):
                row_count = sql_results.get('row_count', 0)
                if row_count > 0:
                    processed_content.append({
                        'type': 'data_summary',
                        'content': f"Query returned {row_count} row{'s' if row_count != 1 else ''}."
                    })
                else:
                    processed_content.append({
                        'type': 'data_summary', 
                        'content': "Query executed successfully but returned no data."
                    })
            
            return {
                'success': True,
                'request_id': analyst_response.get('request_id'),
                'content': processed_content,
                'warnings': analyst_response.get('warnings', []),
                'response_metadata': analyst_response.get('response_metadata', {})
            }
            
        except Exception as e:
            raise Exception(f"Response processing failed: {str(e)}")
    
    def submit_feedback(self, request_id: str, positive: bool, feedback_message: str = "") -> Dict[str, Any]:
        """Submit feedback to Cortex Analyst using REST API"""
        try:
            with self.db.get_connection() as conn:
                # Get the REST authentication token from the connection
                token = conn.rest.token
                
                # Construct the account URL from connection parameters
                account_identifier = self.db.connection_params['account']
                host_url = f"https://{account_identifier}.snowflakecomputing.com"
                
                # Construct request body according to Cortex Analyst feedback API docs
                request_body = {
                    "request_id": request_id,
                    "positive": positive,
                    "feedback_message": feedback_message
                }
                
                # Set required headers according to documentation
                headers = {
                    "Authorization": f'Snowflake Token="{token}"',
                    "Content-Type": "application/json"
                }
                
                # Make the API call to the Cortex Analyst feedback endpoint
                response = requests.post(
                    url=f"{host_url}/api/v2/cortex/analyst/feedback", 
                    json=request_body,
                    headers=headers
                )
                
                # Check for API errors
                if response.status_code >= 400:
                    raise Exception(f"Feedback API error (status {response.status_code}): {response.text}")
                
                return {'success': True, 'message': 'Feedback submitted successfully'}
                
        except Exception as e:
            raise Exception(f"Feedback submission failed: {str(e)}")
